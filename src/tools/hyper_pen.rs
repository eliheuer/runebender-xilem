// Copyright 2025 the Runebender Xilem Authors
// SPDX-License-Identifier: Apache-2.0

//! Hyperbezier pen tool for drawing new paths with automatic smooth curves
//!
//! This tool uses a simplified workflow where you only place on-curve points.
//! Off-curve control points are automatically generated and positioned by
//! the spline solver for G2 continuity.

use crate::editing::{EditSession, EditType, MouseDelegate, MouseEvent};
use crate::entity_id::EntityId;
use crate::path::HyperPath;
use crate::path::Path;
use crate::tools::{Tool, ToolId};
use kurbo::Affine;
use masonry::vello::Scene;
use masonry::vello::peniko;
use std::sync::Arc;

// ===== Constants =====

/// Distance threshold for closing a path (in design units)
const CLOSE_PATH_DISTANCE: f64 = 20.0;

/// Distance threshold for snapping to curves (in screen pixels)
const CURVE_SNAP_DISTANCE: f64 = 10.0;

// ===== HyperPenTool Struct =====

/// The hyperbezier pen tool - used for drawing new paths with smooth curves
///
/// This tool only places on-curve points. Off-curve control points are
/// automatically generated by the spline solver.
#[derive(Debug, Clone, Default)]
pub struct HyperPenTool {
    /// Whether we're actively drawing a path
    drawing: bool,

    /// Current mouse position (for hover detection)
    mouse_pos: Option<kurbo::Point>,

    /// Snapped segment information
    snapped_segment: Option<(crate::path::SegmentInfo, f64)>,

    /// The ID of the path we're currently drawing
    active_path_id: Option<EntityId>,
}

// ===== Tool Implementation =====

impl Tool for HyperPenTool {
    fn id(&self) -> ToolId {
        ToolId::HyperPen
    }

    fn paint(&mut self, scene: &mut Scene, session: &EditSession, _transform: &Affine) {
        use masonry::vello::peniko::Brush;

        let orange_color = crate::theme::point::SELECTED_OUTER;
        let brush = Brush::Solid(orange_color);

        // Check if mouse is hovering near first point (for close feedback)
        let hovering_close = self.check_hovering_close(session);

        // Draw preview dot at current mouse position
        self.draw_preview_dot(scene, session, &brush);

        // Draw close zone indicator if hovering near first point
        if hovering_close {
            self.draw_close_indicator(scene, session, &brush);
        }
    }

    fn edit_type(&self) -> Option<EditType> {
        if self.drawing {
            Some(EditType::Normal)
        } else {
            None
        }
    }
}

// ===== MouseDelegate Implementation =====

impl MouseDelegate for HyperPenTool {
    type Data = EditSession;

    fn left_click(&mut self, event: MouseEvent, data: &mut EditSession) {
        // Check if we're snapped to a curve segment
        if let Some((segment_info, t)) = &self.snapped_segment {
            data.insert_point_on_segment(segment_info, *t);
            self.snapped_segment = None;
            return;
        }

        let design_pos = data.viewport.screen_to_design(event.pos);

        // Check if we're clicking near the first point to close the path
        if self.should_close_path(data, design_pos) {
            self.close_path(data);
            return;
        }

        // Add a new on-curve point
        // All points in hyperbezier mode are smooth by default
        self.add_point(data, design_pos);
    }

    fn mouse_moved(&mut self, event: MouseEvent, data: &mut EditSession) {
        self.mouse_pos = Some(event.pos);

        // Check for curve snapping (only when not actively drawing)
        if !self.drawing {
            if let Some((segment_info, t)) = data.hit_test_segments(event.pos, CURVE_SNAP_DISTANCE)
            {
                self.snapped_segment = Some((segment_info, t));
            } else {
                self.snapped_segment = None;
            }
        } else {
            self.snapped_segment = None;
        }
    }

    fn cancel(&mut self, _data: &mut EditSession) {
        // Finish the current path
        self.active_path_id = None;
        self.drawing = false;
        self.snapped_segment = None;
    }
}

// ===== Helper Methods =====

impl HyperPenTool {
    /// Add a new on-curve point to the current path (or create a new path)
    fn add_point(&mut self, data: &mut EditSession, pos: kurbo::Point) {
        if let Some(path_id) = self.active_path_id {
            // Add to existing path
            if let Some(path) = Self::find_hyper_path_mut(data, path_id) {
                path.add_on_curve_point(pos);
                return;
            }
        }

        // Create a new path
        let path = HyperPath::new(pos);
        let path_id = path.id;

        let mut paths = (*data.paths).clone();
        paths.push(Path::Hyper(path));
        data.paths = Arc::new(paths);

        self.active_path_id = Some(path_id);
        self.drawing = true;
    }

    /// Close the current path
    fn close_path(&mut self, data: &mut EditSession) {
        if let Some(path_id) = self.active_path_id
            && let Some(path) = Self::find_hyper_path_mut(data, path_id)
        {
            path.close_path();
        }

        self.active_path_id = None;
        self.drawing = false;
    }

    /// Find a HyperPath by its ID and return mutable reference
    fn find_hyper_path_mut(data: &mut EditSession, path_id: EntityId) -> Option<&mut HyperPath> {
        let paths = Arc::make_mut(&mut data.paths);
        for path in paths.iter_mut() {
            if let Path::Hyper(hyper) = path
                && hyper.id == path_id
            {
                return Some(hyper);
            }
        }
        None
    }

    /// Check if we should close the path
    fn should_close_path(&self, data: &EditSession, design_pos: kurbo::Point) -> bool {
        let Some(path_id) = self.active_path_id else {
            return false;
        };

        // Find the path and check if we're near the first point
        for path in data.paths.iter() {
            if let Path::Hyper(hyper) = path
                && hyper.id == path_id
                && hyper.len() >= 3
                && let Some(start) = hyper.start_point()
            {
                let distance = ((design_pos.x - start.point.x).powi(2)
                    + (design_pos.y - start.point.y).powi(2))
                .sqrt();
                return distance < CLOSE_PATH_DISTANCE;
            }
        }

        false
    }

    /// Check if mouse is hovering near first point
    fn check_hovering_close(&self, session: &EditSession) -> bool {
        let Some(mouse_screen) = self.mouse_pos else {
            return false;
        };

        let mouse_design = session.viewport.screen_to_design(mouse_screen);
        self.should_close_path(session, mouse_design)
    }

    /// Draw preview dot at current mouse position
    fn draw_preview_dot(
        &self,
        scene: &mut Scene,
        session: &EditSession,
        brush: &masonry::vello::peniko::Brush,
    ) {
        let preview_pos = if let Some((segment_info, t)) = &self.snapped_segment {
            let snapped_design_pos = segment_info.segment.eval(*t);
            Some(session.viewport.to_screen(snapped_design_pos))
        } else {
            self.mouse_pos
        };

        let Some(preview_screen_pos) = preview_pos else {
            return;
        };

        // Draw the preview dot
        let preview_circle = kurbo::Circle::new(preview_screen_pos, 4.0);
        scene.fill(
            peniko::Fill::NonZero,
            Affine::IDENTITY,
            brush,
            None,
            &preview_circle,
        );

        // If snapped, draw indicator ring
        if self.snapped_segment.is_some() {
            let indicator_circle = kurbo::Circle::new(preview_screen_pos, 8.0);
            let stroke = kurbo::Stroke::new(1.5);
            scene.stroke(&stroke, Affine::IDENTITY, brush, None, &indicator_circle);
        }
    }

    /// Draw close zone indicator
    fn draw_close_indicator(
        &self,
        scene: &mut Scene,
        session: &EditSession,
        brush: &masonry::vello::peniko::Brush,
    ) {
        let Some(path_id) = self.active_path_id else {
            return;
        };

        // Find the first point of the active path
        for path in session.paths.iter() {
            if let Path::Hyper(hyper) = path
                && hyper.id == path_id
                && let Some(start) = hyper.start_point()
            {
                let screen_pt = session.viewport.to_screen(start.point);
                let close_zone =
                    kurbo::Circle::new(screen_pt, CLOSE_PATH_DISTANCE * session.viewport.zoom);
                let stroke = kurbo::Stroke::new(1.0);
                scene.stroke(&stroke, Affine::IDENTITY, brush, None, &close_zone);
            }
        }
    }
}
